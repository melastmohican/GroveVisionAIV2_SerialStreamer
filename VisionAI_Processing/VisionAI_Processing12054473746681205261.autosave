import processing.serial.*;
import java.io.ByteArrayInputStream;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;

Serial myPort;
byte[] header = {(byte)0xAA, (byte)0xBB, (byte)0xCC, (byte)0xDD};
PImage img;
int frameCount = 0;
String status = "Searching for Xiao ESP32C3...";

void setup() {
  size(640, 480);
  surface.setResizable(true);
  surface.setTitle("Vision AI Serial Streamer");
  
  println("Available Serial Ports:");
  printArray(Serial.list());
  
  // NOTE: If you know your port name, you can replace Serial.list()[0] 
  // with the name, e.g., new Serial(this, "/dev/cu.usbmodem133201", 115200);
  try {
    if (Serial.list().length > 0) {
      String portName = "/dev/cu.usbmodem133201"; 
      println("Connecting to: " + portName);
      myPort = new Serial(this, portName, 115200);
      status = "Connected to " + portName;
    } else {
      status = "Error: No serial ports found!";
      println(status);
    }
  } catch (Exception e) {
    status = "Error connecting: " + e.getMessage();
    println(status);
  }
}

void draw() {
  background(30);
  
  if (myPort != null) {
    // Read serial data and look for frame header
    while (myPort.available() >= 8) {
      if (findHeader()) {
        int imgLen = readInt();
        
        // Validate length to avoid memory issues
        if (imgLen > 0 && imgLen < 200000) {
          byte[] imgData = new byte[imgLen];
          int bytesRead = 0;
          long startTime = millis();
          
          // Read the full JPEG payload with a timeout
          while (bytesRead < imgLen && (millis() - startTime < 1000)) {
            int remaining = imgLen - bytesRead;
            // Read in chunks
            byte[] buffer = new byte[Math.min(remaining, 4096)];
            int n = myPort.readBytes(buffer);
            if (n > 0) {
              System.arraycopy(buffer, 0, imgData, bytesRead, n);
              bytesRead += n;
            }
          }
          
          if (bytesRead == imgLen) {
            PImage newImg = decodeJPEG(imgData);
            if (newImg != null) {
              img = newImg;
              frameCount++;
              status = "Streaming: " + frameCount + " frames received";
            }
          } else {
            println("Timeout or incomplete frame: " + bytesRead + "/" + imgLen);
          }
        }
      }
    }
  }

  // Display the image
  if (img != null) {
    image(img, 0, 0, width, height);
  }
  
  // HUD
  fill(0, 150);
  noStroke();
  rect(0, height - 25, width, 25);
  fill(0, 255, 0);
  textSize(12);
  textAlign(LEFT, CENTER);
  text(status, 10, height - 12);
}

/**
 * Searches the serial buffer for the 4-byte header.
 */
boolean findHeader() {
  int headIdx = 0;
  while (myPort.available() > 0) {
    byte b = (byte)myPort.read();
    if (b == header[headIdx]) {
      headIdx++;
      if (headIdx == 4) return true;
    } else {
      // If mismatch, reset search (could be improved for overlapping headers)
      headIdx = 0;
    }
  }
  return false;
}

/**
 * Reads a 4-byte little-endian integer from the serial port.
 */
int readInt() {
  byte[] b = new byte[4];
  for (int i = 0; i < 4; i++) {
    while (myPort.available() == 0) { /* wait */ }
    b[i] = (byte)myPort.read();
  }
  return (b[0] & 0xFF) | ((b[1] & 0xFF) << 8) | ((b[2] & 0xFF) << 16) | ((b[3] & 0xFF) << 24);
}

/**
 * Decodes a JPEG byte array into a Processing PImage.
 */
PImage decodeJPEG(byte[] bytes) {
  try {
    ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
    BufferedImage bimg = ImageIO.read(bis);
    if (bimg == null) return null;
    
    PImage pimg = new PImage(bimg.getWidth(), bimg.getHeight(), ARGB);
    bimg.getRGB(0, 0, pimg.width, pimg.height, pimg.pixels, 0, pimg.width);
    pimg.updatePixels();
    return pimg;
  } catch (Exception e) {
    println("JPEG Decode Error: " + e.getMessage());
    return null;
  }
}
